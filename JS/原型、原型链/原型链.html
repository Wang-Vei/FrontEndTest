<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>原型链概念</title>
</head>
<body>
    
</body>
</html>
<script>

    // 原型链 

    //只有函数/构造函数才有 prototype 属性  因为函数可以被 new，new出来的 prototype 中有 constructor
    // 被实例化出来的对象 的 __proto__ 为其构造函数的.prototype
    //只有构造函数才有.prototype的属性，对象是没有这个属性的，__proto__ 只是浏览器提供的非标准化的访问对象的构造函数的原型对象的一种方式，其实更标准的是这样 Object.getPrototypeOf( a ) 获取 a 对象的原型对象，因为对象是没有.prototype的，实际上获取的是 a.__proto__.prototype

/*1、函数原型链*/
    // console.dir(Function) //Function
    // console.dir(Function.prototype) // anonymous() ————Function.prorotype(F.p 是对象)
    // console.dir(Function.__proto__) // anonymous() ————Function.prorotype(F.p 是对象)
    // console.dir(Function.__proto__.__proto__) // Object
    // console.dir(Function.__proto__.__proto__.__proto__) // null

    // console.dir(Function.__proto__ === Function.prototype) //true
    // console.dir(Function.prototype.constructor === Function.constructor) //true

    function Person(name) {
        this.a = 1;
        this.b = 2;
        this.name = name
    }
    Person.prototype.say = 'say hi'
    // console.dir(Person) // ƒ Person()
    // console.dir(Person.__proto__) // ƒ anonymous()————Function.prorotype(F.p 是对象)
    // console.dir(Person.__proto__.__proto__) // Object
    // console.dir(Person.__proto__.__proto__.__proto__) // null
    // console.dir(Person.constructor) // Function

    let vince = new Person()
    // console.dir(vince.__proto__) //Object (Person.prototype)
    // console.log(vince.__proto__ === Person.prototype) // true
    // console.log(vince.prototype) // undefined
    // console.log(vince.constructor) // Person
    

</script>